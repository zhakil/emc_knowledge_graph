import React, { useState, useEffect, useRef } from 'react';
import {
  Card,
  Row,
  Col,
  Button,
  Input,
  Space,
  Tooltip,
  Modal,
  message,
  Typography,
  Divider,
  Tag,
  Alert,
  Tree,
  Dropdown,
  Menu,
  Collapse,
  Switch,
  Tabs,
  Drawer,
  List,
  Badge,
  AutoComplete,
  Segmented,
  Progress,
  Upload
} from 'antd';
import type { RcFile } from 'antd/es/upload/interface';
import {
  EditOutlined,
  EyeOutlined,
  SaveOutlined,
  FolderOutlined,
  FileOutlined,
  FileAddOutlined,
  BoldOutlined,
  ItalicOutlined,
  LinkOutlined,
  PictureOutlined,
  TableOutlined,
  OrderedListOutlined,
  UnorderedListOutlined,
  CodeOutlined,
  FullscreenOutlined,
  SettingOutlined,
  DownloadOutlined,
  SearchOutlined,
  FolderOpenOutlined,
  FileMarkdownOutlined,
  CaretRightOutlined,
  CaretDownOutlined,
  DeleteOutlined,
  CopyOutlined,
  PlusOutlined,
  ImportOutlined,
  ExportOutlined,
  SyncOutlined,
  MoreOutlined
} from '@ant-design/icons';
import type { DataNode } from 'antd/es/tree';

const { TextArea } = Input;
const { Title, Text, Paragraph } = Typography;
const { Panel } = Collapse;

interface MarkdownFile {
  id: string;
  name: string;
  content: string;
  lastModified: string;
  path: string;
  tags: string[];
  parentId?: string;
  children?: MarkdownFile[];
  isExpanded?: boolean;
  type: 'file' | 'folder';
  size?: number;
}

interface FileNode extends DataNode {
  fileData: MarkdownFile;
  children?: FileNode[];
}

const ObsidianMarkdownEditor: React.FC = () => {
  const [markdownContent, setMarkdownContent] = useState('');
  const [currentFile, setCurrentFile] = useState<MarkdownFile | null>(null);
  const [files, setFiles] = useState<MarkdownFile[]>([]);
  const [fileTree, setFileTree] = useState<FileNode[]>([]);
  const [previewMode, setPreviewMode] = useState<'edit' | 'preview' | 'split'>('split');
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [showFileTree, setShowFileTree] = useState(true);
  const [showSettings, setShowSettings] = useState(false);
  const [searchTerm, setSearchTerm] = useState('');
  const [filteredFiles, setFilteredFiles] = useState<MarkdownFile[]>([]);
  const [unsavedChanges, setUnsavedChanges] = useState(false);
  const [expandedKeys, setExpandedKeys] = useState<React.Key[]>([]);
  const [selectedKeys, setSelectedKeys] = useState<React.Key[]>([]);
  const [showImportModal, setShowImportModal] = useState(false);
  const [importProgress, setImportProgress] = useState(0);
  
  const editorRef = useRef<HTMLTextAreaElement>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    loadFiles();
    initializeDefaultContent();
  }, []);

  useEffect(() => {
    buildFileTree();
  }, [files]);

  useEffect(() => {
    filterFiles();
  }, [files, searchTerm]);

  const initializeDefaultContent = () => {
    const defaultContent = `# üìö ObsidianÈ£éÊ†ºMarkdownÁºñËæëÂô®

Ê¨¢Ëøé‰ΩøÁî®MarkdownÁºñËæëÂô®ÔºÅÁõÆÂâçÊ≤°Êúâ‰ªª‰ΩïÊñá‰ª∂„ÄÇ

## üöÄ Âø´ÈÄüÂºÄÂßã

### üìÇ Êñá‰ª∂ÁÆ°ÁêÜ
- ÁÇπÂáªÂ∑¶‰æßÂ∑•ÂÖ∑Ê†èÁöÑ **üìÑ** ÂõæÊ†áÂàõÂª∫Êñ∞Êñá‰ª∂
- ÁÇπÂáªÂ∑¶‰æßÂ∑•ÂÖ∑Ê†èÁöÑ **üìÅ** ÂõæÊ†áÂàõÂª∫Êñ∞Êñá‰ª∂Â§π
- ÁÇπÂáªÂ∑¶‰æßÂ∑•ÂÖ∑Ê†èÁöÑ **üì•** ÂõæÊ†áÂØºÂÖ•Âçï‰∏™Êñá‰ª∂
- ÁÇπÂáªÂ∑¶‰æßÂ∑•ÂÖ∑Ê†èÁöÑ **üìÇ** ÂõæÊ†áÂØºÂÖ•Êï¥‰∏™Êñá‰ª∂Â§π

### ‚úèÔ∏è ÁºñËæëÂäüËÉΩ
- **ÂÆûÊó∂È¢ÑËßà**: ÂàÜÂ±èÊàñÁã¨Á´ãÈ¢ÑËßàÊ®°Âºè
- **ËØ≠Ê≥ïÈ´ò‰∫Æ**: MarkdownËØ≠Ê≥ïÊô∫ËÉΩËØÜÂà´
- **Âø´Êç∑Â∑•ÂÖ∑**: ‰∏∞ÂØåÁöÑÁºñËæëÂ∑•ÂÖ∑Ê†è
- **Ëá™Âä®‰øùÂ≠ò**: Èò≤Ê≠¢Êï∞ÊçÆ‰∏¢Â§±

### üîó ÈìæÊé•Á≥ªÁªü
- **ÂÜÖÈÉ®ÈìæÊé•**: [[Êñá‰ª∂Âêç]] Ê†ºÂºèÈìæÊé•Âà∞ÂÖ∂‰ªñÊñáÊ°£
- **Ê†áÁ≠æÁ≥ªÁªü**: #Ê†áÁ≠æ Âø´ÈÄüÂàÜÁ±ªÂíåÊ£ÄÁ¥¢

## üìù ÂàõÂª∫ÊÇ®ÁöÑÁ¨¨‰∏Ä‰∏™ÊñáÊ°£

1. ÁÇπÂáªÂ∑¶‰æßÁöÑ **Êñ∞Âª∫Êñá‰ª∂** ÊåâÈíÆ
2. ÂºÄÂßãÁºñÂÜôÊÇ®ÁöÑMarkdownÂÜÖÂÆπ
3. ‰ΩøÁî® **Ctrl+S** ÊàñÁÇπÂáª‰øùÂ≠òÊåâÈíÆ‰øùÂ≠òÊñáÊ°£

### Á§∫‰æãËØ≠Ê≥ï
**Á≤ó‰ΩìÊñáÊú¨** Âíå *Êñú‰ΩìÊñáÊú¨*

\`\`\`javascript
// ‰ª£Á†ÅÁ§∫‰æã
console.log("Hello World!");
\`\`\`

| Âàó1 | Âàó2 | Âàó3 |
|-----|-----|-----|
| Êï∞ÊçÆ1 | Êï∞ÊçÆ2 | Êï∞ÊçÆ3 |

#Ê†áÁ≠æÁ§∫‰æã #markdown #ÁºñËæëÂô®

---

ÂºÄÂßãÊÇ®ÁöÑÁü•ËØÜÁÆ°ÁêÜ‰πãÊóÖÂêßÔºÅ
`;
    setMarkdownContent(defaultContent);
  };

  const loadFiles = async () => {
    try {
      const response = await fetch('/api/markdown-files');
      if (response.ok) {
        const data = await response.json();
        setFiles(data);
      } else {
        // ÂàùÂßãÁä∂ÊÄÅ‰∏∫Á©∫ÔºåÊ≤°Êúâ‰ªª‰ΩïÊñá‰ª∂ÊàñÊñá‰ª∂Â§π
        setFiles([]);
      }
    } catch (error) {
      console.error('Âä†ËΩΩÊñá‰ª∂Â§±Ë¥•:', error);
      message.error('Âä†ËΩΩÊñá‰ª∂Â§±Ë¥•');
    }
  };

  const buildFileTree = () => {
    const getContextMenu = (item: MarkdownFile) => {
      const menuItems = [
        {
          key: 'new-file',
          label: 'Êñ∞Âª∫Êñá‰ª∂',
          icon: <FileAddOutlined />,
          onClick: () => handleNewFile(item.type === 'folder' ? item : undefined)
        },
        {
          key: 'new-folder',
          label: 'Êñ∞Âª∫Êñá‰ª∂Â§π',
          icon: <FolderOutlined />,
          onClick: () => handleNewFolder(item.type === 'folder' ? item : undefined)
        },
        { type: 'divider' as const },
        {
          key: 'rename',
          label: 'ÈáçÂëΩÂêç',
          icon: <EditOutlined />,
          onClick: () => handleRenameItem(item)
        },
        {
          key: 'delete',
          label: 'Âà†Èô§',
          icon: <DeleteOutlined />,
          danger: true,
          onClick: () => handleDeleteItem(item)
        }
      ];

      return {
        items: menuItems
      };
    };

    const buildNodes = (items: MarkdownFile[]): FileNode[] => {
      return items.map(item => ({
        key: item.id,
        title: (
          <Dropdown
            menu={getContextMenu(item)}
            trigger={['contextMenu']}
          >
            <div 
              style={{ 
                display: 'flex', 
                alignItems: 'center', 
                gap: 8,
                padding: '2px 4px',
                borderRadius: 4,
                cursor: 'pointer'
              }}
              onMouseEnter={(e) => {
                e.currentTarget.style.backgroundColor = '#f5f5f5';
              }}
              onMouseLeave={(e) => {
                e.currentTarget.style.backgroundColor = 'transparent';
              }}
            >
              {item.type === 'folder' ? (
                <FolderOutlined style={{ color: '#faad14' }} />
              ) : (
                <FileMarkdownOutlined style={{ color: '#1890ff' }} />
              )}
              <span style={{ userSelect: 'none' }}>{item.name}</span>
              {item.tags.length > 0 && (
                <Badge count={item.tags.length} size="small" />
              )}
            </div>
          </Dropdown>
        ),
        fileData: item,
        children: item.children ? buildNodes(item.children) : undefined,
        isLeaf: item.type === 'file'
      }));
    };
    
    setFileTree(buildNodes(files));
  };

  const filterFiles = () => {
    if (!searchTerm) {
      setFilteredFiles([]);
      return;
    }

    const getAllFiles = (items: MarkdownFile[]): MarkdownFile[] => {
      const result: MarkdownFile[] = [];
      items.forEach(item => {
        if (item.type === 'file') {
          result.push(item);
        }
        if (item.children) {
          result.push(...getAllFiles(item.children));
        }
      });
      return result;
    };

    const allFiles = getAllFiles(files);
    const filtered = allFiles.filter(file =>
      file.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
      file.content.toLowerCase().includes(searchTerm.toLowerCase()) ||
      file.tags.some(tag => tag.toLowerCase().includes(searchTerm.toLowerCase()))
    );
    setFilteredFiles(filtered);
  };

  const handleFileSelect = (selectedKeys: React.Key[], info: any) => {
    if (selectedKeys.length > 0) {
      const node = info.node;
      if (node.fileData.type === 'file') {
        if (unsavedChanges) {
          Modal.confirm({
            title: 'Êú™‰øùÂ≠òÁöÑÊõ¥Êîπ',
            content: 'ÂΩìÂâçÊñáÊ°£ÊúâÊú™‰øùÂ≠òÁöÑÊõ¥ÊîπÔºåÊòØÂê¶‰øùÂ≠òÔºü',
            okText: '‰øùÂ≠ò',
            cancelText: '‰∏ç‰øùÂ≠ò',
            onOk: () => {
              handleSave();
              openFile(node.fileData);
            },
            onCancel: () => openFile(node.fileData)
          });
        } else {
          openFile(node.fileData);
        }
      }
    }
    setSelectedKeys(selectedKeys);
  };

  const openFile = (file: MarkdownFile) => {
    setCurrentFile(file);
    setMarkdownContent(file.content);
    setUnsavedChanges(false);
  };

  const handleContentChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setMarkdownContent(e.target.value);
    setUnsavedChanges(true);
  };

  const handleSave = async () => {
    if (!currentFile) {
      message.warning('ËØ∑ÂÖàÈÄâÊã©ÊàñÂàõÂª∫‰∏Ä‰∏™Êñá‰ª∂');
      return;
    }

    try {
      const fileData = {
        ...currentFile,
        content: markdownContent,
        lastModified: new Date().toISOString().split('T')[0]
      };

      // Êõ¥Êñ∞Êú¨Âú∞Áä∂ÊÄÅ
      const updateFiles = (items: MarkdownFile[]): MarkdownFile[] => {
        return items.map(item => {
          if (item.id === currentFile.id) {
            return fileData;
          }
          if (item.children) {
            return { ...item, children: updateFiles(item.children) };
          }
          return item;
        });
      };

      setFiles(updateFiles(files));
      setCurrentFile(fileData);
      setUnsavedChanges(false);
      message.success('ÊñáÊ°£‰øùÂ≠òÊàêÂäü');
    } catch (error) {
      message.error('ÊñáÊ°£‰øùÂ≠òÂ§±Ë¥•');
    }
  };

  const handleNewFile = (parentFolder?: MarkdownFile) => {
    const newFile: MarkdownFile = {
      id: `file_${Date.now()}`,
      name: 'Êñ∞Âª∫ÊñáÊ°£.md',
      content: '# Êñ∞Âª∫ÊñáÊ°£\n\nÂºÄÂßãÁºñÂÜôÊÇ®ÁöÑÂÜÖÂÆπ...\n',
      lastModified: new Date().toISOString().split('T')[0],
      path: parentFolder ? `${parentFolder.path}${parentFolder.name}/` : '/',
      tags: [],
      type: 'file',
      size: 0,
      parentId: parentFolder?.id
    };

    if (unsavedChanges) {
      Modal.confirm({
        title: 'Êú™‰øùÂ≠òÁöÑÊõ¥Êîπ',
        content: 'ÂΩìÂâçÊñáÊ°£ÊúâÊú™‰øùÂ≠òÁöÑÊõ¥ÊîπÔºåÊòØÂê¶‰øùÂ≠òÔºü',
        okText: '‰øùÂ≠ò',
        cancelText: '‰∏ç‰øùÂ≠ò',
        onOk: () => {
          handleSave();
          createNewFile(newFile, parentFolder);
        },
        onCancel: () => createNewFile(newFile, parentFolder)
      });
    } else {
      createNewFile(newFile, parentFolder);
    }
  };

  const handleNewFolder = (parentFolder?: MarkdownFile) => {
    Modal.confirm({
      title: 'ÂàõÂª∫Êñ∞Êñá‰ª∂Â§π',
      content: (
        <Input 
          placeholder="ËØ∑ËæìÂÖ•Êñá‰ª∂Â§πÂêçÁß∞"
          id="folder-name-input"
          onPressEnter={(e) => {
            const folderName = (e.target as HTMLInputElement).value;
            if (folderName) {
              createNewFolder(folderName, parentFolder);
              Modal.destroyAll();
            }
          }}
        />
      ),
      onOk: () => {
        const folderName = (document.getElementById('folder-name-input') as HTMLInputElement)?.value;
        if (folderName) {
          createNewFolder(folderName, parentFolder);
        } else {
          message.warning('ËØ∑ËæìÂÖ•Êñá‰ª∂Â§πÂêçÁß∞');
        }
      }
    });
  };

  const createNewFolder = (folderName: string, parentFolder?: MarkdownFile) => {
    const newFolder: MarkdownFile = {
      id: `folder_${Date.now()}`,
      name: folderName,
      content: '',
      lastModified: new Date().toISOString().split('T')[0],
      path: parentFolder ? `${parentFolder.path}${parentFolder.name}/` : '/',
      tags: [],
      type: 'folder',
      parentId: parentFolder?.id,
      children: []
    };

    if (parentFolder) {
      // Ê∑ªÂä†Âà∞Áà∂Êñá‰ª∂Â§π
      const updateFiles = (items: MarkdownFile[]): MarkdownFile[] => {
        return items.map(item => {
          if (item.id === parentFolder.id) {
            return {
              ...item,
              children: [...(item.children || []), newFolder]
            };
          }
          if (item.children) {
            return { ...item, children: updateFiles(item.children) };
          }
          return item;
        });
      };
      setFiles(updateFiles(files));
    } else {
      // Ê∑ªÂä†Âà∞Ê†πÁõÆÂΩï
      setFiles(prev => [...prev, newFolder]);
    }

    message.success('Êñá‰ª∂Â§πÂàõÂª∫ÊàêÂäü');
  };

  const createNewFile = (newFile: MarkdownFile, parentFolder?: MarkdownFile) => {
    if (parentFolder) {
      // Ê∑ªÂä†Âà∞Áà∂Êñá‰ª∂Â§π
      const updateFiles = (items: MarkdownFile[]): MarkdownFile[] => {
        return items.map(item => {
          if (item.id === parentFolder.id) {
            return {
              ...item,
              children: [...(item.children || []), newFile]
            };
          }
          if (item.children) {
            return { ...item, children: updateFiles(item.children) };
          }
          return item;
        });
      };
      setFiles(updateFiles(files));
    } else {
      // Ê∑ªÂä†Âà∞Ê†πÁõÆÂΩï
      setFiles(prev => [...prev, newFile]);
    }
    
    setCurrentFile(newFile);
    setMarkdownContent(newFile.content);
    setUnsavedChanges(false);
  };

  const handleRenameItem = (item: MarkdownFile) => {
    Modal.confirm({
      title: `ÈáçÂëΩÂêç${item.type === 'folder' ? 'Êñá‰ª∂Â§π' : 'Êñá‰ª∂'}`,
      content: (
        <Input 
          placeholder={`ËØ∑ËæìÂÖ•Êñ∞ÁöÑ${item.type === 'folder' ? 'Êñá‰ª∂Â§π' : 'Êñá‰ª∂'}ÂêçÁß∞`}
          defaultValue={item.name}
          id="rename-input"
          onPressEnter={(e) => {
            const newName = (e.target as HTMLInputElement).value;
            if (newName && newName !== item.name) {
              performRename(item, newName);
              Modal.destroyAll();
            }
          }}
        />
      ),
      onOk: () => {
        const newName = (document.getElementById('rename-input') as HTMLInputElement)?.value;
        if (newName && newName !== item.name) {
          performRename(item, newName);
        } else {
          message.warning('ËØ∑ËæìÂÖ•ÊúâÊïàÁöÑÂêçÁß∞');
        }
      }
    });
  };

  const performRename = (item: MarkdownFile, newName: string) => {
    const updateFiles = (items: MarkdownFile[]): MarkdownFile[] => {
      return items.map(fileItem => {
        if (fileItem.id === item.id) {
          return {
            ...fileItem,
            name: newName,
            lastModified: new Date().toISOString().split('T')[0]
          };
        }
        if (fileItem.children) {
          return { ...fileItem, children: updateFiles(fileItem.children) };
        }
        return fileItem;
      });
    };

    setFiles(updateFiles(files));
    if (currentFile?.id === item.id) {
      setCurrentFile({ ...currentFile, name: newName });
    }
    message.success(`${item.type === 'folder' ? 'Êñá‰ª∂Â§π' : 'Êñá‰ª∂'}ÈáçÂëΩÂêçÊàêÂäü`);
  };

  const handleDeleteItem = (item: MarkdownFile) => {
    Modal.confirm({
      title: `Âà†Èô§${item.type === 'folder' ? 'Êñá‰ª∂Â§π' : 'Êñá‰ª∂'}`,
      content: `Á°ÆÂÆöË¶ÅÂà†Èô§${item.type === 'folder' ? 'Êñá‰ª∂Â§π' : 'Êñá‰ª∂'} "${item.name}" ÂêóÔºü${item.type === 'folder' ? 'Ê≠§Êìç‰ΩúÂ∞ÜÂà†Èô§Êñá‰ª∂Â§πÂÜÖÁöÑÊâÄÊúâÂÜÖÂÆπ„ÄÇ' : ''}`,
      okText: 'Âà†Èô§',
      okType: 'danger',
      cancelText: 'ÂèñÊ∂à',
      onOk: () => {
        performDelete(item);
      }
    });
  };

  const performDelete = (item: MarkdownFile) => {
    const updateFiles = (items: MarkdownFile[]): MarkdownFile[] => {
      return items.filter(fileItem => {
        if (fileItem.id === item.id) {
          return false;
        }
        if (fileItem.children) {
          fileItem.children = updateFiles(fileItem.children);
        }
        return true;
      });
    };

    setFiles(updateFiles(files));
    
    // Â¶ÇÊûúÂà†Èô§ÁöÑÊòØÂΩìÂâçÊâìÂºÄÁöÑÊñá‰ª∂ÔºåÊ∏ÖÁ©∫ÁºñËæëÂô®
    if (currentFile?.id === item.id) {
      setCurrentFile(null);
      setMarkdownContent('');
      setUnsavedChanges(false);
    }
    
    message.success(`${item.type === 'folder' ? 'Êñá‰ª∂Â§π' : 'Êñá‰ª∂'}Âà†Èô§ÊàêÂäü`);
  };

  const handleImportFiles = async (fileList: RcFile[]) => {
    console.log('ÂºÄÂßãÂØºÂÖ•Êñá‰ª∂ÔºåÊï∞Èáè:', fileList.length);
    setImportProgress(0);
    setShowImportModal(true);

    try {
      setImportProgress(10);

      // ÊåâÊñá‰ª∂Â§πË∑ØÂæÑÁªÑÁªáÊñá‰ª∂
      const filesByPath: { [path: string]: RcFile[] } = {};
      const folderStructure: { [path: string]: string[] } = {};

      console.log('ÂàÜÊûêÊñá‰ª∂ÁªìÊûÑ...');

      fileList.forEach(file => {
        const fullPath = file.webkitRelativePath || file.name;
        const pathParts = fullPath.split('/');
        
        // ÊûÑÂª∫Êñá‰ª∂Â§πÁªìÊûÑ
        let currentPath = '';
        pathParts.slice(0, -1).forEach((part: string) => {
          const parentPath = currentPath;
          currentPath = currentPath ? `${currentPath}/${part}` : part;
          
          if (!folderStructure[parentPath]) {
            folderStructure[parentPath] = [];
          }
          if (!folderStructure[parentPath].includes(currentPath)) {
            folderStructure[parentPath].push(currentPath);
          }
        });

        // ÊåâË∑ØÂæÑÂàÜÁªÑÊñá‰ª∂
        const dirPath = pathParts.slice(0, -1).join('/');
        if (!filesByPath[dirPath]) {
          filesByPath[dirPath] = [];
        }
        filesByPath[dirPath].push(file);
      });

      setImportProgress(30);

      // ÂàõÂª∫Êñá‰ª∂Â§πÁªìÊûÑ
      const newFolders: { [path: string]: MarkdownFile } = {};
      const rootFolders: MarkdownFile[] = [];

      // ÊåâË∑ØÂæÑÊ∑±Â∫¶ÊéíÂ∫èÔºåÁ°Æ‰øùÁà∂Êñá‰ª∂Â§πÂÖàÂàõÂª∫
      const sortedPaths = Object.keys(folderStructure).sort((a, b) => {
        const depthA = a.split('/').filter(p => p).length;
        const depthB = b.split('/').filter(p => p).length;
        return depthA - depthB;
      });

      sortedPaths.forEach(parentPath => {
        folderStructure[parentPath].forEach(folderPath => {
          if (!newFolders[folderPath]) {
            const pathParts = folderPath.split('/');
            const folderName = pathParts[pathParts.length - 1];
            const parentFolderPath = pathParts.slice(0, -1).join('/');

            const newFolder: MarkdownFile = {
              id: `folder_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
              name: folderName,
              content: '',
              lastModified: new Date().toISOString().split('T')[0],
              path: parentFolderPath ? `/${parentFolderPath}/` : '/',
              tags: [],
              type: 'folder',
              children: [],
              parentId: parentFolderPath ? newFolders[parentFolderPath]?.id : undefined
            };

            newFolders[folderPath] = newFolder;

            if (parentFolderPath && newFolders[parentFolderPath]) {
              newFolders[parentFolderPath].children!.push(newFolder);
            } else {
              rootFolders.push(newFolder);
            }
          }
        });
      });

      setImportProgress(50);

      // Â§ÑÁêÜÊñá‰ª∂
      let processedFiles = 0;
      const totalFiles = fileList.length;

      for (const [dirPath, files] of Object.entries(filesByPath)) {
        for (const file of files) {
          try {
            const content = await readFileContent(file);
            const fileName = file.name;

            const newFile: MarkdownFile = {
              id: `file_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
              name: fileName,
              content: content,
              lastModified: new Date().toISOString().split('T')[0],
              path: dirPath ? `/${dirPath}/` : '/',
              tags: extractTagsFromContent(content),
              type: 'file',
              size: file.size,
              parentId: dirPath ? newFolders[dirPath]?.id : undefined
            };

            if (dirPath && newFolders[dirPath]) {
              newFolders[dirPath].children!.push(newFile);
            } else {
              rootFolders.push(newFile);
            }

            processedFiles++;
            setImportProgress(50 + (processedFiles / totalFiles) * 40);
          } catch (error) {
            console.error(`ËØªÂèñÊñá‰ª∂Â§±Ë¥• ${file.name}:`, error);
          }
        }
      }

      // Ê∑ªÂä†Âà∞Êñá‰ª∂ÂàóË°®
      setFiles(prev => [...prev, ...rootFolders]);
      setImportProgress(100);

      message.success(`ÊàêÂäüÂØºÂÖ• ${processedFiles} ‰∏™Êñá‰ª∂`);
      
      setTimeout(() => {
        setShowImportModal(false);
        setImportProgress(0);
      }, 1000);

    } catch (error) {
      console.error('Êñá‰ª∂ÂØºÂÖ•Â§±Ë¥•:', error);
      message.error('Êñá‰ª∂ÂØºÂÖ•Â§±Ë¥•ÔºåËØ∑ÈáçËØï');
      setShowImportModal(false);
      setImportProgress(0);
    }
  };

  // ‰ªéÂÜÖÂÆπ‰∏≠ÊèêÂèñÊ†áÁ≠æ
  const extractTagsFromContent = (content: string): string[] => {
    const tagRegex = /#(\w+)/g;
    const tags: string[] = [];
    let match;
    
    while ((match = tagRegex.exec(content)) !== null) {
      if (!tags.includes(match[1])) {
        tags.push(match[1]);
      }
    }
    
    return tags;
  };

  const handleImportFolder = () => {
    try {
      // Ê£ÄÊü•ÊµèËßàÂô®ÊòØÂê¶ÊîØÊåÅÊñá‰ª∂Â§πÈÄâÊã©
      if (!('webkitdirectory' in document.createElement('input'))) {
        message.error('ÊÇ®ÁöÑÊµèËßàÂô®‰∏çÊîØÊåÅÊñá‰ª∂Â§πÈÄâÊã©ÂäüËÉΩÔºåËØ∑‰ΩøÁî®Chrome„ÄÅEdgeÊàñFirefoxÊµèËßàÂô®');
        return;
      }

      // ÂàõÂª∫‰∏Ä‰∏™Êñá‰ª∂ÈÄâÊã©Âô®ÔºåÊîØÊåÅÈÄâÊã©Â§ö‰∏™Êñá‰ª∂
      const input = document.createElement('input');
      input.type = 'file';
      input.multiple = true;
      input.accept = '.md,.markdown,.txt,.html,.htm';
      input.setAttribute('webkitdirectory', 'true'); // ÊîØÊåÅÊñá‰ª∂Â§πÈÄâÊã©
      
      input.onchange = (e) => {
        try {
          const target = e.target as HTMLInputElement;
          console.log('Êñá‰ª∂ÈÄâÊã©Âô®Ëß¶ÂèëÔºåÊñá‰ª∂Êï∞Èáè:', target.files?.length);
          
          if (target.files && target.files.length > 0) {
            const fileList = Array.from(target.files);
            console.log('ÈÄâÊã©ÁöÑÊñá‰ª∂:', fileList.map(f => f.name));
            
            // ËøáÊª§Âè™‰øùÁïômarkdownÂíåÊñáÊú¨Êñá‰ª∂
            const validFiles = fileList.filter(file => {
              const isValid = /\.(md|markdown|txt|html|htm)$/i.test(file.name);
              if (!isValid) {
                console.log('Ë∑≥ËøáÈùûmarkdownÊñá‰ª∂:', file.name);
              }
              return isValid;
            });
            
            if (validFiles.length === 0) {
              message.warning('ÈÄâÊã©ÁöÑÊñá‰ª∂Â§π‰∏≠Ê≤°ÊúâÊâæÂà∞markdownÊñá‰ª∂(.md, .markdown, .txt)');
              return;
            }
            
            console.log('ÊúâÊïàÊñá‰ª∂Êï∞Èáè:', validFiles.length);
            handleImportFiles(validFiles as RcFile[]);
          } else {
            console.log('Êú™ÈÄâÊã©‰ªª‰ΩïÊñá‰ª∂');
            message.info('Êú™ÈÄâÊã©‰ªª‰ΩïÊñá‰ª∂');
          }
        } catch (error) {
          console.error('Êñá‰ª∂ÈÄâÊã©Â§ÑÁêÜÈîôËØØ:', error);
          message.error('Êñá‰ª∂ÈÄâÊã©Â§ÑÁêÜÂ§±Ë¥•ÔºåËØ∑ÈáçËØï');
        }
      };
      
      input.onerror = (error) => {
        console.error('Êñá‰ª∂ËæìÂÖ•ÈîôËØØ:', error);
        message.error('Êñá‰ª∂ÈÄâÊã©Â§±Ë¥•ÔºåËØ∑ÈáçËØï');
      };
      
      // Ëß¶ÂèëÊñá‰ª∂ÈÄâÊã©Âô®
      input.click();
      
    } catch (error) {
      console.error('ÂàõÂª∫Êñá‰ª∂ÈÄâÊã©Âô®Â§±Ë¥•:', error);
      message.error('Êó†Ê≥ïÂàõÂª∫Êñá‰ª∂ÈÄâÊã©Âô®ÔºåËØ∑Ê£ÄÊü•ÊµèËßàÂô®ËÆæÁΩÆ');
    }
  };

  const readFileContent = (file: RcFile): Promise<string> => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = (e) => {
        resolve(e.target?.result as string);
      };
      reader.onerror = reject;
      reader.readAsText(file, 'UTF-8');
    });
  };

  // Êü•ÊâæÂπ∂ÊâìÂºÄÈìæÊé•ÁöÑÊñá‰ª∂
  const findAndOpenLinkedFile = (linkText: string) => {
    const getAllFiles = (items: MarkdownFile[]): MarkdownFile[] => {
      const result: MarkdownFile[] = [];
      items.forEach(item => {
        if (item.type === 'file') {
          result.push(item);
        }
        if (item.children) {
          result.push(...getAllFiles(item.children));
        }
      });
      return result;
    };

    const allFiles = getAllFiles(files);
    const targetFile = allFiles.find(file => 
      file.name === `${linkText}.md` || 
      file.name === linkText ||
      file.name.includes(linkText)
    );

    if (targetFile) {
      if (unsavedChanges) {
        Modal.confirm({
          title: 'Êú™‰øùÂ≠òÁöÑÊõ¥Êîπ',
          content: 'ÂΩìÂâçÊñáÊ°£ÊúâÊú™‰øùÂ≠òÁöÑÊõ¥ÊîπÔºåÊòØÂê¶‰øùÂ≠òÔºü',
          okText: '‰øùÂ≠ò',
          cancelText: '‰∏ç‰øùÂ≠ò',
          onOk: () => {
            handleSave();
            openFile(targetFile);
          },
          onCancel: () => openFile(targetFile)
        });
      } else {
        openFile(targetFile);
      }
    } else {
      message.info(`Êú™ÊâæÂà∞ÊñáÊ°£: ${linkText}`);
    }
  };

  const renderPreview = () => {
    // Â§ÑÁêÜYAML Front Matter
    const processYAMLFrontMatter = (content: string) => {
      const yamlRegex = /^---\n([\s\S]*?)\n---/;
      const match = content.match(yamlRegex);
      
      if (match) {
        const yamlContent = match[1];
        const remainingContent = content.replace(yamlRegex, '').trim();
        
        // Ëß£ÊûêYAMLÂÜÖÂÆπ
        const yamlLines = yamlContent.split('\n').filter(line => line.trim());
        const yamlHtml = yamlLines.map(line => {
          if (line.includes(':')) {
            const [key, value] = line.split(':').map(s => s.trim());
            return `<div style="margin: 4px 0;">
              <span style="color: #1890ff; font-weight: 500;">${key}:</span> 
              <span style="color: #52c41a; margin-left: 8px;">${value}</span>
            </div>`;
          }
          return `<div style="color: #666; margin: 2px 0;">${line}</div>`;
        }).join('');
        
        const frontMatterHtml = `
          <div style="
            background: linear-gradient(135deg, #f6f9fc 0%, #e9f3ff 100%);
            border: 2px dashed #1890ff;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 20px;
            font-family: 'Courier New', monospace;
          ">
            <div style="
              color: #1890ff; 
              font-weight: bold; 
              margin-bottom: 8px;
              display: flex;
              align-items: center;
              gap: 8px;
            ">
              üìã YAML Front Matter
            </div>
            ${yamlHtml}
          </div>
        `;
        
        return { frontMatter: frontMatterHtml, content: remainingContent };
      }
      
      return { frontMatter: '', content };
    };

    // Â§ÑÁêÜÂÜÖÈÉ®ÈìæÊé•
    const processInternalLinks = (content: string) => {
      return content.replace(/\[\[(.*?)\]\]/gim, (match, linkText) => {
        return `<span 
          class="internal-link" 
          data-link="${linkText}"
          style="
            color: #1890ff; 
            background: #e6f7ff; 
            padding: 2px 6px; 
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid #91d5ff;
            display: inline-block;
            margin: 0 2px;
            transition: all 0.3s ease;
          "
          onmouseover="this.style.background='#bae7ff'; this.style.transform='scale(1.05)'"
          onmouseout="this.style.background='#e6f7ff'; this.style.transform='scale(1)'"
        >üîó ${linkText}</span>`;
      });
    };

    // Â§ÑÁêÜÊ†áÁ≠æ
    const processTags = (content: string) => {
      return content.replace(/#(\w+)/gim, (match, tagText) => {
        return `<span 
          class="tag-link"
          style="
            color: #722ed1; 
            background: #f9f0ff; 
            padding: 2px 6px; 
            border-radius: 4px;
            border: 1px solid #d3adf7;
            display: inline-block;
            margin: 0 2px;
            font-size: 12px;
          "
        >#${tagText}</span>`;
      });
    };

    // Â§ÑÁêÜYAML Front Matter
    const { frontMatter, content } = processYAMLFrontMatter(markdownContent);

    // Âü∫Á°ÄMarkdownÂ§ÑÁêÜ
    let html = content
      .replace(/^# (.*$)/gim, '<h1 style="color: #2c3e50; border-bottom: 2px solid #d4af37; padding-bottom: 8px;">$1</h1>')
      .replace(/^## (.*$)/gim, '<h2 style="color: #34495e; border-bottom: 1px solid #d4af37; padding-bottom: 4px;">$1</h2>')
      .replace(/^### (.*$)/gim, '<h3 style="color: #34495e;">$1</h3>')
      .replace(/\*\*(.*?)\*\*/gim, '<strong style="color: #2c3e50;">$1</strong>')
      .replace(/\*(.*?)\*/gim, '<em style="color: #34495e;">$1</em>')
      .replace(/`(.*?)`/gim, '<code style="background: #f4f4f4; padding: 2px 4px; border-radius: 3px; color: #e74c3c;">$1</code>')
      .replace(/^- (.*$)/gim, '<li style="margin: 4px 0;">$1</li>')
      .replace(/^\d+\. (.*$)/gim, '<li style="margin: 4px 0;">$1</li>')
      .replace(/\n/gim, '<br>');

    // Â§ÑÁêÜÂÜÖÈÉ®ÈìæÊé•ÂíåÊ†áÁ≠æ
    html = processInternalLinks(html);
    html = processTags(html);

    // Â§ÑÁêÜË°®Ê†º
    html = html.replace(/\|(.+)\|/g, (match) => {
      const cells = match.split('|').filter(cell => cell.trim());
      return '<tr>' + cells.map(cell => `<td style="border: 1px solid #d9d9d9; padding: 8px;">${cell.trim()}</td>`).join('') + '</tr>';
    });

    return (
      <div 
        className="markdown-preview"
        style={{ 
          padding: '16px',
          minHeight: '500px',
          backgroundColor: '#fff',
          border: '1px solid #d9d9d9',
          borderRadius: '6px',
          fontFamily: 'SimSun, ÂÆã‰Ωì, serif',
          lineHeight: '1.6'
        }}
        dangerouslySetInnerHTML={{ __html: frontMatter + html }}
        onClick={(e) => {
          const target = e.target as HTMLElement;
          if (target.classList.contains('internal-link')) {
            const linkText = target.getAttribute('data-link');
            if (linkText) {
              findAndOpenLinkedFile(linkText);
            }
          }
        }}
      />
    );
  };

  const insertMarkdown = (syntax: string, placeholder: string = '') => {
    if (editorRef.current) {
      const textarea = editorRef.current;
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      const selectedText = markdownContent.substring(start, end);
      const replacement = syntax.replace(placeholder, selectedText || placeholder);
      
      const newContent = 
        markdownContent.substring(0, start) + 
        replacement + 
        markdownContent.substring(end);
      
      setMarkdownContent(newContent);
      setUnsavedChanges(true);
      
      setTimeout(() => {
        textarea.focus();
        const newPosition = start + replacement.length;
        textarea.setSelectionRange(newPosition, newPosition);
      }, 0);
    }
  };

  const toolbarItems = [
    {
      key: 'bold',
      icon: <BoldOutlined />,
      tooltip: 'Á≤ó‰Ωì (Ctrl+B)',
      action: () => insertMarkdown('**{text}**', '{text}')
    },
    {
      key: 'italic',
      icon: <ItalicOutlined />,
      tooltip: 'Êñú‰Ωì (Ctrl+I)',
      action: () => insertMarkdown('*{text}*', '{text}')
    },
    {
      key: 'link',
      icon: <LinkOutlined />,
      tooltip: 'ÂÜÖÈÉ®ÈìæÊé•',
      action: () => insertMarkdown('[[{text}]]', '{text}')
    },
    {
      key: 'code',
      icon: <CodeOutlined />,
      tooltip: 'Ë°åÂÜÖ‰ª£Á†Å',
      action: () => insertMarkdown('`{text}`', '{text}')
    },
    {
      key: 'image',
      icon: <PictureOutlined />,
      tooltip: 'ÂõæÁâá',
      action: () => insertMarkdown('![{text}](image-url)', '{text}')
    },
    {
      key: 'table',
      icon: <TableOutlined />,
      tooltip: 'Ë°®Ê†º',
      action: () => insertMarkdown('\n| Âàó1 | Âàó2 | Âàó3 |\n|------|------|------|\n| Êï∞ÊçÆ1 | Êï∞ÊçÆ2 | Êï∞ÊçÆ3 |\n')
    },
    {
      key: 'ul',
      icon: <UnorderedListOutlined />,
      tooltip: 'Êó†Â∫èÂàóË°®',
      action: () => insertMarkdown('\n- ÂàóË°®È°π\n- ÂàóË°®È°π\n')
    },
    {
      key: 'ol',
      icon: <OrderedListOutlined />,
      tooltip: 'ÊúâÂ∫èÂàóË°®',
      action: () => insertMarkdown('\n1. ÂàóË°®È°π\n2. ÂàóË°®È°π\n')
    }
  ];

  return (
    <div className="fade-in-up" style={{ height: isFullscreen ? '100vh' : 'auto' }}>
      <Title level={2} style={{ textAlign: 'center', marginBottom: 24 }}>
        üìö ObsidianÈ£éÊ†ºMarkdownÁºñËæëÂô®
      </Title>

      <Row gutter={16} style={{ height: isFullscreen ? 'calc(100vh - 120px)' : '700px' }}>
        {/* Â∑¶‰æßÊñá‰ª∂Ê†ë */}
        {showFileTree && (
          <Col xs={24} sm={8} md={6} style={{ height: '100%' }}>
            <Card 
              title={
                <Space>
                  <FolderOutlined />
                  Êñá‰ª∂ÁÆ°ÁêÜÂô®
                </Space>
              }
              size="small"
              className="chinese-card"
              style={{ height: '100%' }}
              bodyStyle={{ padding: '8px', height: 'calc(100% - 45px)', overflow: 'auto' }}
              extra={
                <Space>
                  <Tooltip title="Êñ∞Âª∫Êñá‰ª∂">
                    <Button 
                      type="text" 
                      size="small" 
                      icon={<FileAddOutlined />} 
                      onClick={() => handleNewFile()}
                    />
                  </Tooltip>
                  <Tooltip title="Êñ∞Âª∫Êñá‰ª∂Â§π">
                    <Button 
                      type="text" 
                      size="small" 
                      icon={<FolderOutlined />} 
                      onClick={() => handleNewFolder()}
                    />
                  </Tooltip>
                  <Tooltip title="ÂØºÂÖ•Êñá‰ª∂">
                    <Upload
                      multiple
                      accept=".md,.markdown,.txt,.html,.htm"
                      showUploadList={false}
                      beforeUpload={(file: RcFile, fileList: RcFile[]) => {
                        console.log('ÈÄöËøáUploadÁªÑ‰ª∂ÂØºÂÖ•Êñá‰ª∂:', fileList.length);
                        handleImportFiles(fileList as RcFile[]);
                        return false;
                      }}
                    >
                      <Button type="text" size="small" icon={<ImportOutlined />} />
                    </Upload>
                  </Tooltip>
                  <Tooltip title="ÂØºÂÖ•Êñá‰ª∂Â§π">
                    <Button 
                      type="text" 
                      size="small" 
                      icon={<FolderOpenOutlined />} 
                      onClick={handleImportFolder}
                    />
                  </Tooltip>
                </Space>
              }
            >
              <Space direction="vertical" style={{ width: '100%', marginBottom: 8 }}>
                <Input
                  size="small"
                  placeholder="ÊêúÁ¥¢Êñá‰ª∂..."
                  prefix={<SearchOutlined />}
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                  allowClear
                />
              </Space>

              {searchTerm && filteredFiles.length > 0 ? (
                <List
                  size="small"
                  dataSource={filteredFiles}
                  renderItem={(file) => (
                    <List.Item
                      style={{ padding: '4px 0', cursor: 'pointer' }}
                      onClick={() => openFile(file)}
                    >
                      <Space>
                        <FileMarkdownOutlined style={{ color: '#1890ff' }} />
                        <Text ellipsis={{ tooltip: file.name }} style={{ maxWidth: 150 }}>
                          {file.name}
                        </Text>
                      </Space>
                    </List.Item>
                  )}
                />
              ) : fileTree.length > 0 ? (
                <Tree
                  showLine
                  switcherIcon={<CaretDownOutlined />}
                  treeData={fileTree}
                  expandedKeys={expandedKeys}
                  selectedKeys={selectedKeys}
                  onExpand={setExpandedKeys}
                  onSelect={handleFileSelect}
                  style={{ background: 'transparent' }}
                />
              ) : (
                <div style={{ 
                  textAlign: 'center', 
                  padding: '40px 20px', 
                  color: '#999',
                  fontSize: '14px'
                }}>
                  <div style={{ marginBottom: 16 }}>
                    <FolderOutlined style={{ fontSize: 48, color: '#d9d9d9' }} />
                  </div>
                  <div style={{ marginBottom: 8 }}>ÊöÇÊó†Êñá‰ª∂</div>
                  <div style={{ fontSize: '12px' }}>
                    ÁÇπÂáª‰∏äÊñπÊåâÈíÆÂàõÂª∫Êñá‰ª∂ÊàñÂØºÂÖ•Êñá‰ª∂Â§π
                  </div>
                </div>
              )}
            </Card>
          </Col>
        )}

        {/* Âè≥‰æßÁºñËæëÂå∫Âüü */}
        <Col xs={24} sm={showFileTree ? 16 : 24} md={showFileTree ? 18 : 24} style={{ height: '100%' }}>
          <Card 
            className="chinese-card" 
            style={{ height: '100%' }}
            bodyStyle={{ padding: '12px', height: 'calc(100% - 45px)' }}
            title={
              <Space>
                <FileMarkdownOutlined />
                {currentFile ? currentFile.name : 'Êñ∞Âª∫ÊñáÊ°£'}
                {unsavedChanges && <Tag color="warning">Êú™‰øùÂ≠ò</Tag>}
              </Space>
            }
            extra={
              <Space>
                <Button
                  type={showFileTree ? 'default' : 'primary'}
                  size="small"
                  icon={<FolderOutlined />}
                  onClick={() => setShowFileTree(!showFileTree)}
                >
                  {showFileTree ? 'ÈöêËóè' : 'ÊòæÁ§∫'}Êñá‰ª∂Ê†ë
                </Button>
                <Segmented
                  size="small"
                  value={previewMode}
                  onChange={setPreviewMode}
                  options={[
                    { label: 'ÁºñËæë', value: 'edit', icon: <EditOutlined /> },
                    { label: 'È¢ÑËßà', value: 'preview', icon: <EyeOutlined /> },
                    { label: 'ÂàÜÂ±è', value: 'split' }
                  ]}
                />
                <Button
                  type="primary"
                  size="small"
                  icon={<SaveOutlined />}
                  onClick={handleSave}
                  disabled={!unsavedChanges}
                >
                  ‰øùÂ≠ò
                </Button>
              </Space>
            }
          >
            {/* Â∑•ÂÖ∑Ê†è */}
            <Space wrap style={{ marginBottom: 12, padding: '8px', background: '#fafafa', borderRadius: '6px' }}>
              {toolbarItems.map(item => (
                <Tooltip key={item.key} title={item.tooltip}>
                  <Button 
                    icon={item.icon}
                    size="small"
                    onClick={item.action}
                  />
                </Tooltip>
              ))}
              <Divider type="vertical" />
              <Tooltip title="ÊèíÂÖ•Ê†áÁ≠æ">
                <Button 
                  size="small" 
                  onClick={() => insertMarkdown('#Ê†áÁ≠æÂêç ')}
                >
                  #Ê†áÁ≠æ
                </Button>
              </Tooltip>
              <Tooltip title="ÊèíÂÖ•ÂÜÖÈÉ®ÈìæÊé•">
                <Button 
                  size="small" 
                  onClick={() => insertMarkdown('[[ÊñáÊ°£Âêç]] ')}
                >
                  [[ÈìæÊé•]]
                </Button>
              </Tooltip>
            </Space>

            {/* ÁºñËæëÂô®‰∏ª‰Ωì */}
            <div style={{ height: 'calc(100% - 80px)' }}>
              <Row gutter={8} style={{ height: '100%' }}>
                {(previewMode === 'edit' || previewMode === 'split') && (
                  <Col xs={24} lg={previewMode === 'split' ? 12 : 24} style={{ height: '100%' }}>
                    <TextArea
                      ref={editorRef}
                      value={markdownContent}
                      onChange={handleContentChange}
                      placeholder="ÂºÄÂßãÁºñÂÜôÊÇ®ÁöÑMarkdownÊñáÊ°£...&#10;&#10;üí° ‰ΩøÁî® [[ÊñáÊ°£Âêç]] ÂàõÂª∫ÂÜÖÈÉ®ÈìæÊé•&#10;üí° ‰ΩøÁî® #Ê†áÁ≠æ Ê∑ªÂä†Ê†áÁ≠æ&#10;üí° ÊîØÊåÅÊãñÊãΩÂØºÂÖ•.mdÊñá‰ª∂"
                      style={{
                        height: '100%',
                        fontFamily: 'Monaco, Menlo, "Ubuntu Mono", monospace',
                        fontSize: '14px',
                        lineHeight: 1.6,
                        resize: 'none',
                        border: '1px solid #d9d9d9',
                        borderRadius: '6px'
                      }}
                      className="chinese-input"
                    />
                  </Col>
                )}
                
                {(previewMode === 'preview' || previewMode === 'split') && (
                  <Col xs={24} lg={previewMode === 'split' ? 12 : 24} style={{ height: '100%' }}>
                    <div style={{ 
                      height: '100%',
                      border: '1px solid #d9d9d9',
                      borderRadius: '6px',
                      backgroundColor: '#fafafa',
                      overflow: 'auto'
                    }}>
                      <div style={{
                        padding: '8px 16px',
                        borderBottom: '1px solid #d9d9d9',
                        backgroundColor: '#f0f0f0',
                        fontWeight: 'bold',
                        display: 'flex',
                        alignItems: 'center',
                        gap: 8,
                        position: 'sticky',
                        top: 0,
                        zIndex: 1
                      }}>
                        <EyeOutlined />
                        È¢ÑËßàÊïàÊûú
                      </div>
                      <div style={{ height: 'calc(100% - 41px)', overflow: 'auto' }}>
                        {renderPreview()}
                      </div>
                    </div>
                  </Col>
                )}
              </Row>
            </div>
          </Card>
        </Col>
      </Row>

      {/* ÂØºÂÖ•ËøõÂ∫¶Ê®°ÊÄÅÊ°Ü */}
      <Modal
        title="ÂØºÂÖ•MarkdownÊñá‰ª∂"
        open={showImportModal}
        footer={null}
        closable={false}
        centered
      >
        <div style={{ textAlign: 'center', padding: '20px 0' }}>
          <div style={{ marginBottom: 16 }}>
            <SyncOutlined spin style={{ fontSize: 24, color: '#1890ff' }} />
          </div>
          <div style={{ marginBottom: 16 }}>
            Ê≠£Âú®ÂØºÂÖ•Êñá‰ª∂... {Math.round(importProgress)}%
          </div>
          <Progress 
            percent={Math.round(importProgress)} 
            status={importProgress === 100 ? 'success' : 'active'}
            strokeColor={{ from: '#108ee9', to: '#87d068' }}
          />
        </div>
      </Modal>
    </div>
  );
};

export default ObsidianMarkdownEditor;